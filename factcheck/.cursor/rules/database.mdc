---
description: Database for our project
globs:
alwaysApply: true
---

Always use Context7.

# Overview
This project makes heavy use of code generation tools, e.g. wire and sqlc.
The project is expected to be hosted with PostgreSQL 16, but code is written cleanly
in order to decouple our it from underlying database.

To decouple data from storage, we define data types twice:
1. Database-coupled types
    These types are generated by sqlc under /data
    and is meant to represent the underlying database types.

2. "Domain" types
    These types are defined at root (Go package factcheck itself).
    They are easy to work with compared to the database-coupled variant,
    have normal Go types, and so on. Our code will mostly work with these types.

Adapters to convert between the two are provided in /data/postgres/adapters.go.

To abstract over database interactions, we divide the database access code into 3 layers,
lowest first:

- Data connector layer in /data
    Code in this layer is generated by sqlc. For example, our generated code for PostgreSQL
    lives inside /data/postgres. This layer of database interaction directly uses database-coupled
    types generated by sqlc.

    Note: We might need to add our own initialization/cleanup code in this package to implement
    graceful shutdown with Wire's cleanup function feature, like in postgres.go

- Repository layer in /repo
    Code in this layer is how the rest of our application sees our database interactions.
    These "repositories" use "domain" types, and simplify extra handling that comes with
    type-safe sqlc generated code.

# Integration tests [local]
Despite having Nix flake outputs for integration test components,
I myself do not have Nix on my local machine and rely on running PostgreSQL Docker instance
for integration testing. If you did notice that the database is not up and running,
DO NOT start any services, containers, and processes on your own. Alert me.

# Integration tests [CI]
This project uses [GitHub Actions workflow](/.github/workflows/go-test.yaml)
for automated integration tests. The GitHub Actions workflow makes heavy use of Nix flake,
to pin everything and bring up database container.

# Schema evolution and code change steps
We fully embrace sqlc for our database access. This does mean that if we want
to change anything about database interaction, we'll first have to go and change
sqlc definitions under (data conntector directory)[/factcheck/data].

Due to our heavy use of code generation and rigorous testing, we need to have a
simplified way of addressing changes regarding database interactions, so we divided
our changes into following high-level types

## New queries required
If we need new queries but not new schema for PostgreSQL, then we can just add that
new SQL query to our sqlc definitions inside /data/postgres/query.sql.

We can then run the following command to generate new Go queries:

```shell
sqlc generate
```

## Updating queries
If our existing queries really do need to evolve, then we'll have to:

1. Update SQL queries in /data/postgres/query.sql
2. Generate new data connector code with sqlc
3. Update repository code to support the new SQL queries, if need be

### Schema changes and migrations
When schema changes occur, we'll probably need to do a lot, but probably in this order:

1. Update SQL schema in /data/postgres/query.sql like here https://docs.sqlc.dev/en/latest/howto/ddl.html
2. Generate new data connector code with sqlc to check that our queries are not broken
3. If queries were broken, fix the queries and regenerate
4. Update domain types to match new schema
5. Update repositories to match new domain types
7. Update adapters to address the changes
8. Leave the rest to me