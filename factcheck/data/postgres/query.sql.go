// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    id, topic_id, text, type, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, topic_id, text, type, created_at, updated_at
`

type CreateMessageParams struct {
	ID        pgtype.UUID        `json:"id"`
	TopicID   pgtype.UUID        `json:"topic_id"`
	Text      string             `json:"text"`
	Type      string             `json:"type"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ID,
		arg.TopicID,
		arg.Text,
		arg.Type,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO topics (
    id, name, status, result, result_status, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, name, status, result, result_status, created_at, updated_at
`

type CreateTopicParams struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Status       string             `json:"status"`
	Result       pgtype.Text        `json:"result"`
	ResultStatus pgtype.Text        `json:"result_status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic,
		arg.ID,
		arg.Name,
		arg.Status,
		arg.Result,
		arg.ResultStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserMessage = `-- name: CreateUserMessage :one
INSERT INTO user_messages (
    id, replied_at, message_id, metadata, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, replied_at, message_id, metadata, created_at, updated_at
`

type CreateUserMessageParams struct {
	ID        pgtype.UUID        `json:"id"`
	RepliedAt pgtype.Timestamptz `json:"replied_at"`
	MessageID pgtype.UUID        `json:"message_id"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateUserMessage(ctx context.Context, arg CreateUserMessageParams) (UserMessage, error) {
	row := q.db.QueryRow(ctx, createUserMessage,
		arg.ID,
		arg.RepliedAt,
		arg.MessageID,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UserMessage
	err := row.Scan(
		&i.ID,
		&i.RepliedAt,
		&i.MessageID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const deleteTopic = `-- name: DeleteTopic :exec
DELETE FROM topics WHERE id = $1
`

func (q *Queries) DeleteTopic(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTopic, id)
	return err
}

const deleteUserMessage = `-- name: DeleteUserMessage :exec
DELETE FROM user_messages WHERE id = $1
`

func (q *Queries) DeleteUserMessage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserMessage, id)
	return err
}

const getMessage = `-- name: GetMessage :one
SELECT id, topic_id, text, type, created_at, updated_at FROM messages WHERE id = $1
`

func (q *Queries) GetMessage(ctx context.Context, id pgtype.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopic = `-- name: GetTopic :one
SELECT id, name, status, result, result_status, created_at, updated_at FROM topics WHERE id = $1
`

func (q *Queries) GetTopic(ctx context.Context, id pgtype.UUID) (Topic, error) {
	row := q.db.QueryRow(ctx, getTopic, id)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMessage = `-- name: GetUserMessage :one
SELECT id, replied_at, message_id, metadata, created_at, updated_at FROM user_messages WHERE id = $1
`

func (q *Queries) GetUserMessage(ctx context.Context, id pgtype.UUID) (UserMessage, error) {
	row := q.db.QueryRow(ctx, getUserMessage, id)
	var i UserMessage
	err := row.Scan(
		&i.ID,
		&i.RepliedAt,
		&i.MessageID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listMessagesByTopic = `-- name: ListMessagesByTopic :many
SELECT id, topic_id, text, type, created_at, updated_at FROM messages WHERE topic_id = $1 ORDER BY created_at ASC
`

func (q *Queries) ListMessagesByTopic(ctx context.Context, topicID pgtype.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.TopicID,
			&i.Text,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT id, name, status, result, result_status, created_at, updated_at FROM topics ORDER BY created_at DESC
`

func (q *Queries) ListTopics(ctx context.Context) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Result,
			&i.ResultStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopicsByStatus = `-- name: ListTopicsByStatus :many
SELECT id, name, status, result, result_status, created_at, updated_at FROM topics WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) ListTopicsByStatus(ctx context.Context, status string) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopicsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Result,
			&i.ResultStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMessagesByMessage = `-- name: ListUserMessagesByMessage :many
SELECT id, replied_at, message_id, metadata, created_at, updated_at FROM user_messages WHERE message_id = $1 ORDER BY created_at ASC
`

func (q *Queries) ListUserMessagesByMessage(ctx context.Context, messageID pgtype.UUID) ([]UserMessage, error) {
	rows, err := q.db.Query(ctx, listUserMessagesByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserMessage
	for rows.Next() {
		var i UserMessage
		if err := rows.Scan(
			&i.ID,
			&i.RepliedAt,
			&i.MessageID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessage = `-- name: UpdateMessage :one
UPDATE messages SET 
    text = $2,
    type = $3,
    updated_at = $4
WHERE id = $1 RETURNING id, topic_id, text, type, created_at, updated_at
`

type UpdateMessageParams struct {
	ID        pgtype.UUID        `json:"id"`
	Text      string             `json:"text"`
	Type      string             `json:"type"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessage,
		arg.ID,
		arg.Text,
		arg.Type,
		arg.UpdatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopic = `-- name: UpdateTopic :one
UPDATE topics SET 
    name = $2,
    status = $3,
    result = $4,
    result_status = $5,
    updated_at = $6
WHERE id = $1 RETURNING id, name, status, result, result_status, created_at, updated_at
`

type UpdateTopicParams struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Status       string             `json:"status"`
	Result       pgtype.Text        `json:"result"`
	ResultStatus pgtype.Text        `json:"result_status"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateTopic(ctx context.Context, arg UpdateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopic,
		arg.ID,
		arg.Name,
		arg.Status,
		arg.Result,
		arg.ResultStatus,
		arg.UpdatedAt,
	)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserMessage = `-- name: UpdateUserMessage :one
UPDATE user_messages SET 
    replied_at = $2,
    metadata = $3,
    updated_at = $4
WHERE id = $1 RETURNING id, replied_at, message_id, metadata, created_at, updated_at
`

type UpdateUserMessageParams struct {
	ID        pgtype.UUID        `json:"id"`
	RepliedAt pgtype.Timestamptz `json:"replied_at"`
	Metadata  []byte             `json:"metadata"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateUserMessage(ctx context.Context, arg UpdateUserMessageParams) (UserMessage, error) {
	row := q.db.QueryRow(ctx, updateUserMessage,
		arg.ID,
		arg.RepliedAt,
		arg.Metadata,
		arg.UpdatedAt,
	)
	var i UserMessage
	err := row.Scan(
		&i.ID,
		&i.RepliedAt,
		&i.MessageID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
