// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignMessageGroupToTopic = `-- name: AssignMessageGroupToTopic :one
UPDATE message_groups SET
    topic_id = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, topic_id, status, name, text, text_sha1, language, created_at, updated_at
`

type AssignMessageGroupToTopicParams struct {
	ID      pgtype.UUID `json:"id"`
	TopicID pgtype.UUID `json:"topic_id"`
}

func (q *Queries) AssignMessageGroupToTopic(ctx context.Context, arg AssignMessageGroupToTopicParams) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, assignMessageGroupToTopic, arg.ID, arg.TopicID)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignMessageV2ToMessageGroup = `-- name: AssignMessageV2ToMessageGroup :one
UPDATE messages_v2 SET
    group_id = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at
`

type AssignMessageV2ToMessageGroupParams struct {
	ID      pgtype.UUID `json:"id"`
	GroupID pgtype.UUID `json:"group_id"`
}

func (q *Queries) AssignMessageV2ToMessageGroup(ctx context.Context, arg AssignMessageV2ToMessageGroupParams) (MessagesV2, error) {
	row := q.db.QueryRow(ctx, assignMessageV2ToMessageGroup, arg.ID, arg.GroupID)
	var i MessagesV2
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TopicID,
		&i.GroupID,
		&i.TypeUser,
		&i.Type,
		&i.Text,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const assignMessageV2ToTopic = `-- name: AssignMessageV2ToTopic :one
UPDATE messages_v2 SET
    topic_id = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at
`

type AssignMessageV2ToTopicParams struct {
	ID      pgtype.UUID `json:"id"`
	TopicID pgtype.UUID `json:"topic_id"`
}

func (q *Queries) AssignMessageV2ToTopic(ctx context.Context, arg AssignMessageV2ToTopicParams) (MessagesV2, error) {
	row := q.db.QueryRow(ctx, assignMessageV2ToTopic, arg.ID, arg.TopicID)
	var i MessagesV2
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TopicID,
		&i.GroupID,
		&i.TypeUser,
		&i.Type,
		&i.Text,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countTopicsByStatus = `-- name: CountTopicsByStatus :one
SELECT COUNT(*) FROM topics WHERE status = $1
`

func (q *Queries) CountTopicsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countTopicsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTopicsGroupByStatusDynamicV2 = `-- name: CountTopicsGroupByStatusDynamicV2 :many
SELECT t.status, COUNT(DISTINCT t.id) as count
FROM topics t
LEFT JOIN message_groups m ON t.id = m.topic_id
WHERE 1=1
    AND CASE
        WHEN $1::text != '' THEN t.id::text LIKE $1::text
        ELSE true
    END
    AND CASE
        WHEN $2::text != '' THEN (
            CASE
                WHEN m.language = 'th' THEN m.text LIKE $2::text COLLATE "C"
                WHEN m.language = 'en' THEN m.text ILIKE $2::text
                ELSE m.text ILIKE $2::text  -- fallback for unknown language
            END
        )
        ELSE true
    END
GROUP BY t.status
`

type CountTopicsGroupByStatusDynamicV2Params struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

type CountTopicsGroupByStatusDynamicV2Row struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountTopicsGroupByStatusDynamicV2(ctx context.Context, arg CountTopicsGroupByStatusDynamicV2Params) ([]CountTopicsGroupByStatusDynamicV2Row, error) {
	rows, err := q.db.Query(ctx, countTopicsGroupByStatusDynamicV2, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountTopicsGroupByStatusDynamicV2Row
	for rows.Next() {
		var i CountTopicsGroupByStatusDynamicV2Row
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countTopicsGroupedByStatus = `-- name: CountTopicsGroupedByStatus :many
SELECT status, COUNT(*) as count
FROM topics
GROUP BY status
`

type CountTopicsGroupedByStatusRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) CountTopicsGroupedByStatus(ctx context.Context) ([]CountTopicsGroupedByStatusRow, error) {
	rows, err := q.db.Query(ctx, countTopicsGroupedByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountTopicsGroupedByStatusRow
	for rows.Next() {
		var i CountTopicsGroupedByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAnswer = `-- name: CreateAnswer :one
INSERT INTO answers (
    id, topic_id, text, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, topic_id, text, created_at, updated_at
`

type CreateAnswerParams struct {
	ID        pgtype.UUID        `json:"id"`
	TopicID   pgtype.UUID        `json:"topic_id"`
	Text      string             `json:"text"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateAnswer(ctx context.Context, arg CreateAnswerParams) (Answer, error) {
	row := q.db.QueryRow(ctx, createAnswer,
		arg.ID,
		arg.TopicID,
		arg.Text,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessageGroup = `-- name: CreateMessageGroup :one
INSERT INTO message_groups (
    id, status, topic_id, name, text, text_sha1, language, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, topic_id, status, name, text, text_sha1, language, created_at, updated_at
`

type CreateMessageGroupParams struct {
	ID        pgtype.UUID        `json:"id"`
	Status    string             `json:"status"`
	TopicID   pgtype.UUID        `json:"topic_id"`
	Name      string             `json:"name"`
	Text      string             `json:"text"`
	TextSha1  string             `json:"text_sha1"`
	Language  pgtype.Text        `json:"language"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateMessageGroup(ctx context.Context, arg CreateMessageGroupParams) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, createMessageGroup,
		arg.ID,
		arg.Status,
		arg.TopicID,
		arg.Name,
		arg.Text,
		arg.TextSha1,
		arg.Language,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessageV2 = `-- name: CreateMessageV2 :one
INSERT INTO messages_v2 (
    id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at
`

type CreateMessageV2Params struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    string             `json:"user_id"`
	TopicID   pgtype.UUID        `json:"topic_id"`
	GroupID   pgtype.UUID        `json:"group_id"`
	TypeUser  string             `json:"type_user"`
	Type      string             `json:"type"`
	Text      string             `json:"text"`
	Language  pgtype.Text        `json:"language"`
	Metadata  []byte             `json:"metadata"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateMessageV2(ctx context.Context, arg CreateMessageV2Params) (MessagesV2, error) {
	row := q.db.QueryRow(ctx, createMessageV2,
		arg.ID,
		arg.UserID,
		arg.TopicID,
		arg.GroupID,
		arg.TypeUser,
		arg.Type,
		arg.Text,
		arg.Language,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i MessagesV2
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TopicID,
		&i.GroupID,
		&i.TypeUser,
		&i.Type,
		&i.Text,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO topics (
    id, name, description, status, result, result_status, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, description, status, result, result_status, created_at, updated_at
`

type CreateTopicParams struct {
	ID           pgtype.UUID        `json:"id"`
	Name         string             `json:"name"`
	Description  string             `json:"description"`
	Status       string             `json:"status"`
	Result       pgtype.Text        `json:"result"`
	ResultStatus pgtype.Text        `json:"result_status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, createTopic,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.Result,
		arg.ResultStatus,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnswer = `-- name: DeleteAnswer :exec
DELETE FROM answers WHERE id = $1
`

func (q *Queries) DeleteAnswer(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAnswer, id)
	return err
}

const deleteMessageGroup = `-- name: DeleteMessageGroup :exec
DELETE FROM message_groups WHERE id = $1
`

func (q *Queries) DeleteMessageGroup(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessageGroup, id)
	return err
}

const deleteMessageV2 = `-- name: DeleteMessageV2 :exec
DELETE FROM messages_v2 WHERE id = $1
`

func (q *Queries) DeleteMessageV2(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessageV2, id)
	return err
}

const deleteTopic = `-- name: DeleteTopic :exec
DELETE FROM topics WHERE id = $1
`

func (q *Queries) DeleteTopic(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTopic, id)
	return err
}

const getAnswerByID = `-- name: GetAnswerByID :one
SELECT id, topic_id, text, created_at, updated_at FROM answers WHERE id = $1
`

func (q *Queries) GetAnswerByID(ctx context.Context, id pgtype.UUID) (Answer, error) {
	row := q.db.QueryRow(ctx, getAnswerByID, id)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswerByTopicID = `-- name: GetAnswerByTopicID :one
SELECT id, topic_id, text, created_at, updated_at FROM answers WHERE topic_id = $1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetAnswerByTopicID(ctx context.Context, topicID pgtype.UUID) (Answer, error) {
	row := q.db.QueryRow(ctx, getAnswerByTopicID, topicID)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageGroup = `-- name: GetMessageGroup :one
SELECT id, topic_id, status, name, text, text_sha1, language, created_at, updated_at FROM message_groups WHERE id = $1
`

func (q *Queries) GetMessageGroup(ctx context.Context, id pgtype.UUID) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, getMessageGroup, id)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageGroupBySHA1 = `-- name: GetMessageGroupBySHA1 :one
SELECT id, topic_id, status, name, text, text_sha1, language, created_at, updated_at FROM message_groups WHERE text_sha1 = $1
`

func (q *Queries) GetMessageGroupBySHA1(ctx context.Context, textSha1 string) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, getMessageGroupBySHA1, textSha1)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageV2 = `-- name: GetMessageV2 :one
SELECT id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at FROM messages_v2 WHERE id = $1
`

func (q *Queries) GetMessageV2(ctx context.Context, id pgtype.UUID) (MessagesV2, error) {
	row := q.db.QueryRow(ctx, getMessageV2, id)
	var i MessagesV2
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TopicID,
		&i.GroupID,
		&i.TypeUser,
		&i.Type,
		&i.Text,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopic = `-- name: GetTopic :one
SELECT id, name, description, status, result, result_status, created_at, updated_at FROM topics WHERE id = $1
`

func (q *Queries) GetTopic(ctx context.Context, id pgtype.UUID) (Topic, error) {
	row := q.db.QueryRow(ctx, getTopic, id)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopicStatus = `-- name: GetTopicStatus :one
SELECT status FROM topics WHERE id = $1
`

func (q *Queries) GetTopicStatus(ctx context.Context, id pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getTopicStatus, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const listAnswersByTopicID = `-- name: ListAnswersByTopicID :many
SELECT id, topic_id, text, created_at, updated_at FROM answers WHERE topic_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListAnswersByTopicID(ctx context.Context, topicID pgtype.UUID) ([]Answer, error) {
	rows, err := q.db.Query(ctx, listAnswersByTopicID, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Answer
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.TopicID,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageGroupDynamic = `-- name: ListMessageGroupDynamic :many
SELECT  mg.id, mg.topic_id, mg.name, mg.text, mg.text_sha1, mg.language, mg.created_at, mg.updated_at
FROM message_groups mg
WHERE 1=1
    AND CASE
        WHEN $1::text != '' THEN mg.text::text LIKE $1::text
        ELSE true
    END
    AND CASE
        WHEN array_length($2::text[], 1) > 0 THEN mg.id = ANY(($2::text[])::uuid[])
        ELSE true
    END
    AND CASE
        WHEN array_length($3::text[], 1) > 0 THEN NOT (mg.id = ANY(($3::text[])::uuid[]))
        ELSE true
    END
ORDER BY mg.created_at DESC
LIMIT CASE WHEN $5::integer = 0 THEN NULL ELSE $5::integer END
OFFSET CASE WHEN $4::integer = 0 THEN 0 ELSE $4::integer END
`

type ListMessageGroupDynamicParams struct {
	Text    string   `json:"text"`
	IDIn    []string `json:"id_in"`
	IDNotIn []string `json:"id_not_in"`
	Offset  int32    `json:"offset"`
	Limit   int32    `json:"limit"`
}

func (q *Queries) ListMessageGroupDynamic(ctx context.Context, arg ListMessageGroupDynamicParams) ([]MessageGroup, error) {
	rows, err := q.db.Query(ctx, listMessageGroupDynamic,
		arg.Text,
		arg.IDIn,
		arg.IDNotIn,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageGroup
	for rows.Next() {
		var i MessageGroup
		if err := rows.Scan(
			&i.ID,
			&i.TopicID,
			&i.Name,
			&i.Text,
			&i.TextSha1,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageGroupsByTopic = `-- name: ListMessageGroupsByTopic :many
SELECT id, topic_id, status, name, text, text_sha1, language, created_at, updated_at FROM message_groups WHERE topic_id = $1 ORDER BY created_at ASC
`

func (q *Queries) ListMessageGroupsByTopic(ctx context.Context, topicID pgtype.UUID) ([]MessageGroup, error) {
	rows, err := q.db.Query(ctx, listMessageGroupsByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageGroup
	for rows.Next() {
		var i MessageGroup
		if err := rows.Scan(
			&i.ID,
			&i.TopicID,
			&i.Status,
			&i.Name,
			&i.Text,
			&i.TextSha1,
			&i.Language,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesV2ByGroup = `-- name: ListMessagesV2ByGroup :many
SELECT id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at FROM messages_v2 WHERE group_id = $1 ORDER BY created_at ASC
`

func (q *Queries) ListMessagesV2ByGroup(ctx context.Context, groupID pgtype.UUID) ([]MessagesV2, error) {
	rows, err := q.db.Query(ctx, listMessagesV2ByGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessagesV2
	for rows.Next() {
		var i MessagesV2
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TopicID,
			&i.GroupID,
			&i.TypeUser,
			&i.Type,
			&i.Text,
			&i.Language,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesV2ByTopic = `-- name: ListMessagesV2ByTopic :many
SELECT id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at FROM messages_v2 WHERE topic_id = $1 ORDER BY created_at ASC
`

func (q *Queries) ListMessagesV2ByTopic(ctx context.Context, topicID pgtype.UUID) ([]MessagesV2, error) {
	rows, err := q.db.Query(ctx, listMessagesV2ByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessagesV2
	for rows.Next() {
		var i MessagesV2
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TopicID,
			&i.GroupID,
			&i.TypeUser,
			&i.Type,
			&i.Text,
			&i.Language,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopics = `-- name: ListTopics :many
SELECT DISTINCT t.id, t.name, t.description, t.status, t.result, t.result_status, t.created_at, t.updated_at
FROM topics t
ORDER BY t.created_at DESC
LIMIT CASE WHEN $1::integer = 0 THEN NULL ELSE $1::integer END
OFFSET CASE WHEN $2::integer = 0 THEN 0 ELSE $2::integer END
`

type ListTopicsParams struct {
	Column1 int32 `json:"column_1"`
	Column2 int32 `json:"column_2"`
}

func (q *Queries) ListTopics(ctx context.Context, arg ListTopicsParams) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopics, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Result,
			&i.ResultStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopicsByStatus = `-- name: ListTopicsByStatus :many
SELECT DISTINCT t.id, t.name, t.description, t.status, t.result, t.result_status, t.created_at, t.updated_at
FROM topics t
WHERE status = $1
ORDER BY t.created_at DESC
LIMIT CASE WHEN $2::integer = 0 THEN NULL ELSE $2::integer END
OFFSET CASE WHEN $3::integer = 0 THEN 0 ELSE $3::integer END
`

type ListTopicsByStatusParams struct {
	Status  string `json:"status"`
	Column2 int32  `json:"column_2"`
	Column3 int32  `json:"column_3"`
}

func (q *Queries) ListTopicsByStatus(ctx context.Context, arg ListTopicsByStatusParams) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopicsByStatus, arg.Status, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Result,
			&i.ResultStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopicsDynamicV2 = `-- name: ListTopicsDynamicV2 :many
SELECT DISTINCT t.id, t.name, t.description, t.status, t.result, t.result_status, t.created_at, t.updated_at
FROM topics t
LEFT JOIN message_groups mg ON t.id = mg.topic_id
LEFT JOIN messages_v2 m ON mg.id = m.group_id
WHERE 1=1
    AND CASE
        WHEN $1::text != '' THEN t.id::text LIKE $1::text
        ELSE true
    END
    AND CASE
        WHEN array_length($2::text[], 1) > 0 THEN t.status = ANY($2::text[])
        ELSE true
    END
    AND CASE
        WHEN $3::text != '' THEN (
            CASE
                WHEN mg.language = 'th' THEN m.text LIKE $3::text COLLATE "C"
                WHEN mg.language = 'en' THEN m.text ILIKE $3::text
                ELSE m.text ILIKE $3::text  -- fallback for unknown language
            END
        )
        ELSE true
    END
ORDER BY t.created_at DESC
LIMIT CASE WHEN $4::integer = 0 THEN NULL ELSE $4::integer END
OFFSET CASE WHEN $4::integer = 0 THEN 0 ELSE $5::integer END
`

type ListTopicsDynamicV2Params struct {
	Column1 string   `json:"column_1"`
	Column2 []string `json:"column_2"`
	Column3 string   `json:"column_3"`
	Column4 int32    `json:"column_4"`
	Column5 int32    `json:"column_5"`
}

func (q *Queries) ListTopicsDynamicV2(ctx context.Context, arg ListTopicsDynamicV2Params) ([]Topic, error) {
	rows, err := q.db.Query(ctx, listTopicsDynamicV2,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.Result,
			&i.ResultStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveTopic = `-- name: ResolveTopic :one
UPDATE topics SET
    result = $2,
    result_status = $3,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, status, result, result_status, created_at, updated_at
`

type ResolveTopicParams struct {
	ID           pgtype.UUID `json:"id"`
	Result       pgtype.Text `json:"result"`
	ResultStatus pgtype.Text `json:"result_status"`
}

func (q *Queries) ResolveTopic(ctx context.Context, arg ResolveTopicParams) (Topic, error) {
	row := q.db.QueryRow(ctx, resolveTopic, arg.ID, arg.Result, arg.ResultStatus)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const topicExists = `-- name: TopicExists :one
SELECT EXISTS (SELECT 1 from topics where id = $1)
`

func (q *Queries) TopicExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, topicExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unassignMessageGroupFromTopic = `-- name: UnassignMessageGroupFromTopic :one
UPDATE message_groups SET
    topic_id = NULL,
    updated_at = NOW()
WHERE id = $1 RETURNING id, topic_id, status, name, text, text_sha1, language, created_at, updated_at
`

func (q *Queries) UnassignMessageGroupFromTopic(ctx context.Context, id pgtype.UUID) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, unassignMessageGroupFromTopic, id)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unassignMessageV2FromTopic = `-- name: UnassignMessageV2FromTopic :one
UPDATE messages_v2 SET
    topic_id = NULL,
    updated_at = NOW()
WHERE id = $1 RETURNING id, user_id, topic_id, group_id, type_user, type, text, language, metadata, created_at, updated_at
`

func (q *Queries) UnassignMessageV2FromTopic(ctx context.Context, id pgtype.UUID) (MessagesV2, error) {
	row := q.db.QueryRow(ctx, unassignMessageV2FromTopic, id)
	var i MessagesV2
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TopicID,
		&i.GroupID,
		&i.TypeUser,
		&i.Type,
		&i.Text,
		&i.Language,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMessageGroupName = `-- name: UpdateMessageGroupName :one
UPDATE message_groups SET
    name = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, topic_id, status, name, text, text_sha1, language, created_at, updated_at
`

type UpdateMessageGroupNameParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) UpdateMessageGroupName(ctx context.Context, arg UpdateMessageGroupNameParams) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, updateMessageGroupName, arg.ID, arg.Name)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMessageGroupStatus = `-- name: UpdateMessageGroupStatus :one
UPDATE message_groups SET
    status = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, topic_id, status, name, text, text_sha1, language, created_at, updated_at
`

type UpdateMessageGroupStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateMessageGroupStatus(ctx context.Context, arg UpdateMessageGroupStatusParams) (MessageGroup, error) {
	row := q.db.QueryRow(ctx, updateMessageGroupStatus, arg.ID, arg.Status)
	var i MessageGroup
	err := row.Scan(
		&i.ID,
		&i.TopicID,
		&i.Status,
		&i.Name,
		&i.Text,
		&i.TextSha1,
		&i.Language,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopicDescription = `-- name: UpdateTopicDescription :one
UPDATE topics SET
    description = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, status, result, result_status, created_at, updated_at
`

type UpdateTopicDescriptionParams struct {
	ID          pgtype.UUID `json:"id"`
	Description string      `json:"description"`
}

func (q *Queries) UpdateTopicDescription(ctx context.Context, arg UpdateTopicDescriptionParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopicDescription, arg.ID, arg.Description)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopicName = `-- name: UpdateTopicName :one
UPDATE topics SET
    name = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, status, result, result_status, created_at, updated_at
`

type UpdateTopicNameParams struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) UpdateTopicName(ctx context.Context, arg UpdateTopicNameParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopicName, arg.ID, arg.Name)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTopicStatus = `-- name: UpdateTopicStatus :one
UPDATE topics SET
    status = $2,
    updated_at = NOW()
WHERE id = $1 RETURNING id, name, description, status, result, result_status, created_at, updated_at
`

type UpdateTopicStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateTopicStatus(ctx context.Context, arg UpdateTopicStatusParams) (Topic, error) {
	row := q.db.QueryRow(ctx, updateTopicStatus, arg.ID, arg.Status)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.Result,
		&i.ResultStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
